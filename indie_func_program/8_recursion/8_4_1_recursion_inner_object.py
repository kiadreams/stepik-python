# ---------------Работает только со списками без вложенных списков------------
def get_total_old(lst: list[int]) -> int:
    total = 0
    for value in lst:
        total += value
    return total


"""
Для того, чтобы функция могла работать со списками произвольной вложенности,
необходима рекурсия!!!
Рекурсия очень полезна в ситуациях, когда вы имеете дело с объектами, в которых
имеется произвольная вложенность. Словосочетание «произвольная вложенность»
можно также понимать как «неопределенная вложенность».
"""
# -------__--Работает только со списками произвольной вложенности----__--------
print('Работает только со списками произвольной вложенности'.center(100, '-'))


def get_total(lst):
    total = 0
    for value in lst:
        # проверяем тип элемента
        if isinstance(value, list):
            # если это список, то
            # вызываем рекурсивный шаг для
            # нахождения суммы его элементов
            sum_nested = get_total(value)
            total += sum_nested
        else:
            # Если это число, то сразу добавляем к total
            total += value
    return total


print(get_total([1, 2, 3, 4, 5]))
print(get_total([[1, 2, 3], [4, [5, 6]], 7]))
print(get_total([1, 2, 3, 4, 5,
                 [6, 7, 8,
                  [9, 1, [2, [3], 4], 5, 6]]]))
