from inspect import getgeneratorstate

# -------------------------Состояния генератора----------------------------
print('Состояния генератора'.center(100, '-'))


def my_coro(a):
    print('Запускаем корутину')
    b = yield a
    print(f'Получено значение b={b}')
    c = yield a + b
    print(f'Получено значение c={c}')


coro = my_coro(10)
print(getgeneratorstate(coro))
next(coro)
print(getgeneratorstate(coro))
print(coro.send(15))
print(getgeneratorstate(coro))
try:
    print(coro.send(43))
except StopIteration:
    print(getgeneratorstate(coro))

"""
У генератора имеется всего четыре состояния и он может находиться в одном из
них. Вот в каких состояниях может находиться генератор:
 - GEN_CREATED: ожидание начала выполнения;
 - GEN_RUNNING: в настоящее время выполняется интерпретатором;
 - GEN_SUSPENDED: в настоящее время приостановлено на выражении yield;
 - GEN_CLOSED: выполнение завершено.

Состояние GEN_RUNNING можно увидеть только в многопоточной программе.

Определить текущее состояние генератора поможет функция getgeneratorstate,
которая находится в модуле inspect
    "from inspect import getgeneratorstate"
"""

# -------------------------Метод генератора .close()--------------------------
print('Метод генератора .close()'.center(100, '-'))


def infinity_coro():
    print("Запускаем нашу корутину!")
    try:
        while True:
            value = yield
            print('Передано значение', value)
    except GeneratorExit:
        print("Закрывается генератор")


coro = infinity_coro()
next(coro)
coro.send('Hi')
coro.send(100)
coro.close()

"""
Но метод .close() работает на самом деле очень интересно. В момент вызова он
возбуждает исключение GeneratorExit внутри сопрограммы в месте оператора yiled,
на котором был приостановлен генератор. И вы можете это исключение обработать,
чтобы убедиться, что действительно именно GeneratorExit будет возникать от
вызова метода .close().
"""

# -------------------------Метод генератора .throw()--------------------------
print('Метод генератора .throw()'.center(100, '-'))

"""
Необработанные исключения приведут к тому, что генератор автоматически завершит
работу и к нему уже нельзя будет обращаться через next или метод .send().
Поэтому обычно создают блок try-except, в котором обрабатывают возможные
типы исключений.
Вы можете передавать в метод throw() не только название исключение, но и
сопровождающий текст. Сделать это можно двумя способами:
- вызвать класс-исключение и передать в него текст
 - coro.throw(KeyError("Ошибка ключа"))
-передать текст вторым аргументом в метод
 - coro.throw(KeyError, "Ошибка ключа")
Результат будет одинаков: с типом исключения появиться дополнительный текст
"""



def my_coro(a):
    print('Запускаем корутину')
    b = yield a
    print(f'Получено значение b={b}')
    c = yield a + b
    print(f'Получено значение c={c}')


coro = my_coro(5)
next(coro)
coro.send(3)
coro.throw(ZeroDivisionError, 'этот текст отообразится')