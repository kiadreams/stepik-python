import asyncio


"""
    Еще одной распространенной причиной тупика является невыполнение корутиной 
обязанности освободить ресурс. Обычно это вызвано тем, что корутина вызывает 
ошибку или исключение в критическом разделе, что мешает корутине освободить 
ресурс. В данном уроке приведем пример с блокировкой asyncio.Lock, но помните, 
что такая ошибка может возникнуть при работе с любыми ресурсами, которые нужно 
освобождать (семафоры - semaphore*, барьеры - barrier*, события - event* и 
т.д.).
    Этот код иллюстрирует, как может произойти взаимная блокировка из-за 
неудачного приобретения и освобождения блокировки в асинхронной программе. 
Если корутина приобретает блокировку и затем происходит исключение до того, 
как блокировка будет освобождена, другая корутина, которая пытается приобрести 
ту же блокировку, будет блокирована навсегда, поскольку первая корутина 
никогда не освобождает блокировку.
"""


async def task(lock):
    print("Задача приобретает блокировку...")
    # Приобретаем блокировку
    await lock.acquire()

    # Генерируем исключение, симулируя ошибку
    raise Exception("Произошло что-то плохое")

    # этот код никогда не будет выполнен
    print("Задача освобождает блокировку...")
    lock.release()


async def main():
    lock = asyncio.Lock()
    asyncio.create_task(task(lock))
    await asyncio.sleep(1)
    print("Основная функция приобретает блокировку...")
    # Используем метод acquire() для асинхронного приобретения блокировки
    await lock.acquire()

    # этот код не будет выполнен
    lock.release()


asyncio.run(main())

"""
Решение проблемы: всегда освобождайте ресурсы.
Если вы планируете вручную освобождать ресурсы, то делайте это в конструкции 
try/finally. 
    # приобретаем блокировку
    lock.acquire()  
    try:
        # Критический участок кода...
    finally:
        # всегда освобождаем блокировку
        lock.release()  
Или используйте менеджеры контекста:
    # Конструкция with автоматически устанавливает и освобождает блокировку. 
    async with lock:  
        # критический участок кода...
Преимущество менеджера контекста заключается в том, что блокировка всегда 
освобождается, как только выходит из блока, независимо от того, как она 
происходит, например, нормальный возврат, ошибка возврата или исключение.
"""
