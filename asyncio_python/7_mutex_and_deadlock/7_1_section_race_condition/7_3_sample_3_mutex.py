"""
В библиотеке asyncio нет классического мьютекса, но для синхронизации доступа к ресурсам можно
использовать объекты типа Lock. Они функционируют аналогично мьютексам и предоставляют методы для
получения и освобождения блокировки.
    import asyncio
    lock = asyncio.Lock()
Основные методы для работы с объектом блокировки – это acquire() и release(). Метод acquire()
позволяет получить блокировку, а метод release() – освободить ее. Метод acquire()является
асинхронным и должен быть вызван с использованием ключевого слова await, в то время как release()
вызывается напрямую без await.
    await lock.acquire()
    # Критическая секция кода, реализующая любую логику
    lock.release()
Метод acquire() блокирует доступ к критической секции кода до тех пор, пока мьютекс не будет
освобожден исполняемой в нём задачей.  Другими словами, пока задача, исполняемая внутри
критического блока кода, не завершит свою работу, никакие другие задачи не смогут получить доступ
к этому блоку кода. Критическая секция кода должна быть ограничена вызовами методов acquire() и
release().
"""

import asyncio


# Эмуляция комнаты с замком
class Room:
    def __init__(self):
        self.lock = asyncio.Lock()

    async def use(self, name):
        # Захват мьютекса
        await self.lock.acquire()
        try:
            print(f"{name} вошел в комнату.")
            # Имитация выполнения работы внутри комнаты
            await asyncio.sleep(1)
            print(f"{name} вышел из комнаты.")
        finally:
            # Освобождение мьютекса
            self.lock.release()


async def person(name, room):
    # Человек (задача) пытается использовать комнату
    print(f"{name} хочет войти в комнату.")
    await room.use(name)


async def main():
    room = Room()  # Инициализация комнаты с замком

    # Создание задач для нескольких людей, пытающихся войти в комнату
    await asyncio.gather(
        person("Алексей", room), person("Мария", room), person("Иван", room)
    )


asyncio.run(main())
