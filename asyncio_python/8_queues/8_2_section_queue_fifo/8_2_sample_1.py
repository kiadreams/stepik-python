"""
Добавление элемента с возможной блокировкой (если очередь заполнена - корутина блокируется и
ожидает возможности добавить элемент в очередь):
    # добавить объект в очередь
    await queue.put(item)
Элемент также можно добавить в очередь без блокировки с помощью метода put_nowait(). Если в
очереди нет места, то метод put_nowait() вызывает исключение asyncio.QueueFull
Это исключение можно обработать следующим образом.
    try:
        # попытка добавить элемент
        queue.put_nowait(item)
    except asyncio.QueueFull:
        # ...

Элементы можно получить из очереди, вызвав метод get().
На самом деле это корутина, которую нужно дождаться. В данный момент в очереди может не быть
элементов для извлечения, и вызывающей корутине может потребоваться блокировка до тех пор, пока
элемент не станет доступным.
    # получить элемент из очереди
    item = await queue.get()
Извлеченный элемент будет самым старым добавленным элементом.
Элемент можно извлечь из очереди без блокировки с помощью метода get_nowait().
Этот метод не является корутиной и немедленно вернет элемент, если он доступен, в противном случае
произойдет сбой с исключением asyncio.QueueEmpty.
    ...
    try:
        # попытка получить элемент
        item = queue.get_nowait()
    except asyncio.QueueEmpty:
        # ...

Также можем проверить, заполнена ли очередь полностью, с помощью метода full(), который возвращает
True, если очередь содержит максимально возможное количество элементов.
Если очередь была инициализирована с maxsize=0 (по умолчанию), то full() никогда не вернет True,
так как, если  maxsize меньше или равен нулю, то размер очереди бесконечен.
    ...
    # проверить заполнена ли очередь полностью
    if queue.full():
        # ...

Контроль выполнения задач в очереди:
Метод task_done() вызывается после обработки элемента очереди. Он указывает, что обработка элемента
очереди завершена. При вызове этого метода счетчик, который был инкрементирован методом put(),
декрементируется. Когда счетчик достигнет нуля (т.е. все элементы очереди будут обработаны), метод
join() разблокирует выполнение программы. Обычно этот метод вызывается внутри цикла while, который
обрабатывает элементы очереди. Пример использования:
    while True:
        # получить элемент из очереди
        item = await queue.get()
        process_item(item)
        # оповестить очередь, что обработка задачи завершена
        queue.task_done()
Другие корутины могут быть заинтересованы в том, чтобы знать, когда все элементы, добавленные в
очередь, были извлечены и помечены как выполненные, поэтому task_done() может быть весьма полезен.
    # ждем, пока все элементы в очереди будут отмечены как выполненные
    await queue.join()
Если очередь пуста или все элементы уже отмечены как выполненные, то корутина join() вернется
немедленно.
"""

import asyncio
from random import random


async def producer(queue):
    print("Производитель: запущен")
    for i in range(10):
        value = random()
        await asyncio.sleep(value)
        await queue.put(value)  # добавление в очередь
    await queue.put(None)  # отправка сигнала об окончании
    print("Производитель: Done")


async def consumer(queue):
    print("Потребитель: Запущен")
    # выполнение работы
    while True:
        item = await queue.get()  # получение элемента из очереди
        if item is None:  # проверка сигнала остановки
            break
        print(f">got {item}")
    print("Потребитель: Done")


# точка входа корутины
async def main():
    # создаем общую очередь
    queue = asyncio.Queue()
    # запустить производителя и потребителя
    await asyncio.gather(producer(queue), consumer(queue))

asyncio.run(main())
